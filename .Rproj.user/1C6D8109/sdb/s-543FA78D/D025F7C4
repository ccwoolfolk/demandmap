{
    "collab_server" : "",
    "contents" : "### ----- makeWeightsInput -----------------------------------------------------\n### Create a data.frame with labels and weights columns\n### labels = character[n].\n### weights = numeric[n].\n### ----------------------------------------------------------------------------\nmakeWeightsInput <- function(labels, weights) {\n  stopifnot(length(labels) == length(weights))\n\n  data.frame(\n    stringsAsFactors=FALSE,\n    labels=labels,\n    weights=weights\n  )\n}\n\n### ----- getData --------------------------------------------------------------\n### Get the full state-level data set\n### Returns a tibble\n### ----------------------------------------------------------------------------\ngetData <- function () {\n  raw <- read_excel(\n    paste(dataPath, 'raw.xlsx', sep=''),\n    col_types = 'text',\n    skip=1\n  )\n\n  data <- raw[-1, ]\n  colTypes <- strsplit(x='text\ttext\ttext\ttext\ttext\tnumeric\tnumeric\tnumeric\tnumeric\tnumeric\tnumeric\tnumeric\tnumeric\tnumeric\tnumeric\tnumeric\tnumeric\tnumeric', split='\\t')[[1]]\n  for (i in 1:length(colTypes)) {\n    type <- colTypes[i]\n    if (type == 'numeric') {\n      values <- as.numeric(pull(data[ ,i]))\n      values[is.na(values)] <- 0 # Note, this replaces any NAs with zero for now\n      data[ ,i] <- values\n    }\n  }\n  return(data)\n}\n\n### ----- getTotal -------------------------------------------------------------\n### Calculate the total of a column, aggregated by NAICS.id\n### naics = vector of NAICS.id values\n### columnLabel = expr[1]. Column heading - ESTAB, EMP, etc.\n### Returns vector of numeric values representing sum of column for NAICS.id's\n### ----------------------------------------------------------------------------\ngetTotal <- function (data, naics, columnLabel) {\n  totalQuo <- enquo(columnLabel)\n\n  industryTotals <- group_by(data, NAICS.id) %>% summarize(\n    total=sum(!! totalQuo)\n  )\n\n  industryTotals$total[match(naics, industryTotals$NAICS.id)]\n}\n\n### ----- getWeights -----------------------------------------------------------\n### labels = vector of NAICS.id values, column names, etc. [n]\n### wts = matrix[n, 2] with labels in col 1 and weights in col 2 (0.5, etc)\n### Returns vector of numeric values repsenting weights for corres. labels\n### ----------------------------------------------------------------------------\ngetWeights <- function (labels, wts) {\n  wts[match(labels, wts[ ,1]), 2]\n}\n\n### ----- addPctColumn ---------------------------------------------------------\n### Add a \"pctLABEL\" column that shows the % of total for that label (EMP) in that NAICS code\n### data = tibble\n### columnLabels = character[n].\n### Returns tibble with \"pctCOLUMNLABEL\" column attached\n### ----------------------------------------------------------------------------\naddPctColumn <- function(data, columnLabels) {\n  if (length(columnLabels) < 1) return(data)\n\n  columnLabel <- columnLabels[1]\n  currentData <- addPctColumn(data, columnLabels[-1])\n\n  pctLabel <- paste('pct', columnLabel, sep='')\n  totals <- getTotal(currentData, currentData$NAICS.id, (!! sym(columnLabel)))\n  currentData %>% mutate(\n    (!! pctLabel) :=  (!! sym(columnLabel)) / totals\n  )\n}\n\n### ----- addScoreColumn ---------------------------------------------------------\n### Add a \"score\" column that calcs score based on both industry and label weights\n### data = tibble\n### industryWeights = data.frame with 'labels' and 'weights' columns\n### metricWeights = data.frame with 'labels' and 'weights' columns\n### Returns tibble with \"score\" column attached\n### ----------------------------------------------------------------------------\naddScoreColumn <- function (data, industryWeights, metricWeights) {\n  cols <- paste('pct', metricWeights[ ,1], sep='')\n  rawScores <- data[ ,cols] * matrix(metricWeights$weights, nrow=nrow(data), ncol=nrow(metricWeights), byrow=TRUE)\n  industryAppliedWts <- getWeights(data$NAICS.id, industryWeights)\n  combScore <- rowSums(rawScores) * industryAppliedWts\n  return(\n    mutate(\n      data,\n      score=combScore\n    )\n  )\n}\n\n### ----- aggregateStateScores -------------------------------------------------\n### Convert a tibble with \"stateName\" and \"totalScore\" column into a simple data.frame for plotting\n### data = tibble\n### Returns tibble with state, totalScore, long, lat, and printScore cols\n### ----------------------------------------------------------------------------\naggregateStateScores <- function(data) {\n  if (!is.tbl(data)) stop('aggregateStateScores requires a tibble')\n  if (!('totalScore' %in% names(data))) stop('No totalScore column header')\n  if (!('stateName' %in% names(data))) stop('No stateName column header')\n\n  stateIdx <- match(data$stateName, datasets::state.name)\n  if (any(is.na(stateIdx))) stop(paste('Invalid stateName \"', data$stateName[is.na(stateIdx)][1], '\"', sep=''))\n  long <- datasets::state.center$x[stateIdx]\n  lat <- datasets::state.center$y[stateIdx]\n  printScore <- round(data$totalScore * 100, 0)\n\n  df <- data.frame(\n    state=data$stateName,\n    totalScore=data$totalScore,\n    long=long,\n    lat=lat,\n    printScore=printScore\n  )\n\n  return(as_tibble(df))\n}\n\n### ----- data2stateScores ------------------------------------------------------\n###\n### rawData = tibble representing Census Bureau data set\n### metricWeights = data.frame with \"labels\" (char.) and \"weights\" (num.)\n### industryWeights = data.frame with \"labels\" (char.) and \"weights\" (num.)\n###\n### Returns a tibble with state, totalScore, long, lat, and printScore cols\n### ----------------------------------------------------------------------------\ndata2stateScores <- function(rawData, metricWeights, industryWeights) {\n  dataWithMetricColumns <- addPctColumn(rawData, as.character(metricWeights$labels))\n  dataWithScores <- addScoreColumn(dataWithMetricColumns, industryWeights, metricWeights)\n\n  stateScoreInputs <- dataWithScores %>% select(\n    `GEO.display-label`, score\n  ) %>% group_by(`GEO.display-label`) %>% summarize(\n    totalScore= sum(score)\n  )\n\n  names(stateScoreInputs) <- c('stateName', 'totalScore')\n  stateScores <- aggregateStateScores(stateScoreInputs)\n}\n\n### ----- plotDemandMap ---------------------------------------------------------\n### Create a ggplot object representing the demand map\n### mapData = data.frame w/ long, lat, and region columns; region = state name\n###           This provides the lat/lon for the state boundaries\n### stateScoresData = tibble w/ state, totalScore, printScore, lat, and long\n###                   This provides the lat/lon for the state midpoints\n### Returns ggplot\n### ----------------------------------------------------------------------------\nplotDemandMap <- function(mapData, stateScoresData) {\n  gg <- ggplot()\n  gg <- gg + geom_map(data=mapData, map=mapData,\n                      aes(map_id=tolower(region)),\n                      fill=\"#ffffff\", color=\"black\", size=0.15)\n  gg <- gg + geom_map(data=stateScoresData, map=mapData,\n                      aes(fill=totalScore, map_id=tolower(state)),\n                      color=\"#ffffff\", size=0.15) + coord_quickmap()\n  gg + geom_text(data=stateScoresData, aes(x=long, y=lat, label=printScore), color='white', size=3)\n}\n",
    "created" : 1537729906262.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "1811594398",
    "id" : "D025F7C4",
    "lastKnownWriteTime" : 1537730181,
    "last_content_update" : 1537730181140,
    "path" : "~/Projects/demandmap/R/functions.R",
    "project_path" : "R/functions.R",
    "properties" : {
        "tempName" : "Untitled1"
    },
    "relative_order" : 3,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}